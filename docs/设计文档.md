# 设计文档

### struct Store
Tikv 的实例信息，假设他会打上关于拓扑信息的标签
每个对应一块磁盘，一台机器上面可以开启多个（如果有多块磁盘）

```{go}
type Store struct {
	ID     int
	Labels map[string]string
}
```

### struct Region
```{go}
type Region struct {
	Replicas []int
}
```
表示每个数据块对应的副本分布，Replicas 储存的是对应的 StoreID

### struct RegionStore
```{go}
type RegionStore struct {
	Stores  Stores
	Region  Region
	Index []int

	Tmp *Store
}
```
将 Store 和 Region 结合起来的数据结构, 为了解决每次遍历副本的时候都需要去 Store 里面逐个 id 匹配的问题，额外建立了 Index 索引，可以直接通过下标访问

同时提供一些统计和聚合操作

### struct Strategy

```{go}
type Strategy struct {
	MaxReplicas int // 总副本数

	// 可选参数, 如果为 0 表示不限制
	MaxDatacenterCnt       int // 最多分布的 Datacenter 数
	MaxReplicaInDatacenter int // 单个 Datacenter 的副本上限
	MaxReplicaInRack       int // 单个 Rack 的副本上限
	MinReplicaRequireSSD   int // 需要放到 SSD 的副本数量
}
```

表示了对应的策略配置信息，结构体定义由以下规则总结出来的：
>
1. 3 副本随机分布在不同的节点
2. 节点分布在多个 Rack 上，3 副本中的任意 2 副本都不能在同一个 Rack
3. 3 DC，3 副本分别分布在不同的 DC
4. 2 DC，每个 DC 内有多个 Rack，3 副本分布在不同的 Rack 且不能 3 副本都在同一个 DC
5. 2 DC，5 副本，其中一个 DC 放置 3 副本，另外一个 DC 放置 2 副本
6. 3 副本，要求存储在 ssd 磁盘
7. 3 副本至少有一个副本存储在 ssd 磁盘


对应配置细节 (按顺序给出对应的配置值)

```
1. {3, 0, 0, 0, 0}
2. {3, 0, 0, 1, 0}
3. {3, 3, 1, 0, 0}
4. {3, 2, 2, 1, 0}
5. {5, 2, 3, 0, 0}
6. {3, 0, 0, 0, 3}
7. {3, 0, 0, 0, 1}
```

## 算分机制

#### 1. 策略指标分数

分数的意义在于了解当前副本集分布情况和是否符合策略，哪些维度不符合，所以这个分数是一个数组。
每个分数如果值大于等于0，表明满足了条件，如果小于0，表示不满足。

#### 2. 迁移代价分数
迁移代价分数指的是当一个副本从某个节点迁移到另一个节点所需的代价，分数越高表示代价越高。

目前按照拓扑结构的层级来 [Datacenter, Rack, Host, ID]
比较会按照顺序比较两个 Store 的差别，直到遇到第一个不一样的信息则停止搜索，返回 (len - 下标) 分数。(例：Datacenter 不同则4， Rack不同则3， Host不同2，实例不同则1)

## 迁移策略

流程采用迭代的方法完成，每次迁移一个节点，直到符合条件或者无法找到满足条件的分布。
所以每次迁移前，会根据策略分数，知道哪些指标达不到(负分)，通过多次迭代按顺序处理使各个指标分数能够合格。
每当某个指标不合格时，会找到可能需要迁移的节点列表，再找到可以迁移过去的节点列表，两两组合构成一个新副本分布，计算他们的分数，最后取最优的结果进行迁移。

在上述比较中，怎么判断优劣性：
1. 如果当前指标分数更高了或者满足了，则更优
2. 在当前指标满足的情况下，如果代价更低，则更优
3. 其他则忽略

如果找不到更优的结果，则停止（认为没有更优解）。

指标的解决有顺序区分，确保不会在多次迭代计算中陷入死循环。

#### 缺陷

1. 存在一种情况是单次迁移拿不到更优的结果并且是不符合策略的，但是基于这次迁移后再进行计算便能够找到更优。这种情况需要在失败后再进行更深层度的组合 C(n, m), 替换的副本数从1上升到总副本数，复杂度极高（这部分没有实现）。
2. 没有从全局的角度看待整个迁移过程，仍有可能会拿不到代价最低的最优解。




