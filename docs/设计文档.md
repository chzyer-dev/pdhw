# 设计文档

### struct Store
Tikv 的实例信息，假设他会打上关于拓扑信息的标签
每个对应一块磁盘，一台机器上面可以开启多个（如果有多块磁盘）

```{go}
type Store struct {
	ID     int
	Labels map[string]string
}
```

### struct Region
```{go}
type Region struct {
	Replicas []int
}
```
表示每个数据块对应的副本分布，Replicas 储存的是对应的 StoreID

### struct RegionStore
```{go}
type RegionStore struct {
	Stores  Stores
	Region  Region
	Index []int

	Tmp *Store
}
```
将 Store 和 Region 结合起来的数据结构, 为了解决每次遍历副本的时候都需要去 Store 里面逐个 id 匹配的问题，额外建立了 Index 索引，可以直接通过下标访问

同时提供一些统计和聚合操作

### struct Strategy

```{go}
type Strategy struct {
	MaxReplicas int // 总副本数

	// 可选参数, 如果为 0 表示不限制
	MaxDatacenterCnt       int // 最多分布的 Datacenter 数
	MaxReplicaInDatacenter int // 单个 Datacenter 的副本上限
	MaxReplicaInRack       int // 单个 Rack 的副本上限
	MinReplicaRequireSSD   int // 需要放到 SSD 的副本数量
}
```

表示了对应的策略配置信息，结构体定义由以下规则总结出来的：
>
1. 3 副本随机分布在不同的节点
2. 节点分布在多个 Rack 上，3 副本中的任意 2 副本都不能在同一个 Rack
3. 3 DC，3 副本分别分布在不同的 DC
4. 2 DC，每个 DC 内有多个 Rack，3 副本分布在不同的 Rack 且不能 3 副本都在同一个 DC
5. 2 DC，5 副本，其中一个 DC 放置 3 副本，另外一个 DC 放置 2 副本
6. 3 副本，要求存储在 ssd 磁盘
7. 3 副本至少有一个副本存储在 ssd 磁盘


对应配置细节 (按顺序给出对应的配置值)

```
1. {3, 0, 0, 0, 0}
2. {3, 0, 0, 1, 0}
3. {3, 3, 1, 0, 0}
4. {3, 2, 2, 1, 0}
5. {5, 2, 3, 0, 0}
6. {3, 0, 0, 0, 3}
7. {3, 0, 0, 0, 1}
```

## 算分机制

#### 1. 策略分数

分数的意义在于了解当前副本集分布情况和是否符合策略，哪些维度不符合，所以这个分数是一个数组。
每个分数如果值大于等于0，表明满足了条件，如果小于0，表示不满足。

#### 2. 迁移代价分数
迁移代价分数指的是当一个副本从某个节点迁移到另一个节点所需的代价，分数越高表示代价越高。

目前按照拓扑结构的层级来 [Datacenter, Rack, Host, ID]
比较会按照顺序比较两个 Store 的差别，直到遇到第一个不一样的信息则停止搜索，返回 (len - 下标) 分数。(例：Datacenter 不同则4， Rack不同则3， Host不同2，实例不同则1)

## 迁移策略


